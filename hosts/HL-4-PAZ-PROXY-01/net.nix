{
  globals,
  inputs,
  config,
  ...
}: let
  inherit (inputs.self) lib;
  inherit (inputs.self) secretsPath;

  wgName = "proxy-vps";
  inherit
    (lib.wireguard inputs wgName)
    peerPublicKeyPath
    peerPrivateKeyPath
    peerPresharedKeyPath
    ;

  nodeName = config.node.name;
  opnsense = "HL-3-MRZ-FW-01";
  # config.repo.secrets.local = {
  local = {
    networking = {
      interfaces = {
        wan = {
          hostCidrv4 = "37.120.178.230/22";
          hostCidrv6 = "2a03:4000:6:8128::/64";
          mac = "da:22:45:bf:e9:98";
          gateway = {
            cidrv4 = "37.120.176.1";
            cidrv6 = "fe80::1";
          };
        };
      };
    };
  };
  icfg = local.networking.interfaces.wan;
  wireguardPort = 51820;
  # icfg = config.repo.secrets.local.networking.interfaces.wan;
in {
  # networking.hostId = config.repo.secrets.local.networking.hostId;
  networking.domain = globals.domains.me;

  globals.monitoring.ping.sentinel = {
    hostv4 = lib.net.cidr.ip icfg.hostCidrv4;
    hostv6 = lib.net.cidr.ip icfg.hostCidrv6;
    network = "internet";
  };

  # |----------------------------------------------------------------------| #
  age.secrets.preshared-key = {
    file = "${peerPresharedKeyPath nodeName opnsense secretsPath}";
    mode = "640";
    owner = "systemd-network";
  };
  age.secrets.private-key = {
    file = peerPrivateKeyPath nodeName secretsPath;
    mode = "640";
    owner = "systemd-network";
  };

  # |----------------------------------------------------------------------| #
  # Forwarding required for forgejo 9922->22
  boot.kernel.sysctl."net.ipv4.ip_forward" = 1;

  boot.initrd.systemd.network = {
    enable = true;
    networks = {inherit (config.systemd.network.networks) "10-wan";};
  };

  # |----------------------------------------------------------------------| #
  systemd.network.networks = {
    "10-wan" = {
      address = [
        icfg.hostCidrv4
        icfg.hostCidrv6
      ];
      gateway = ["fe80::1"];
      routes = [
        {Destination = "172.31.1.1";}
        {
          Gateway = icfg.gateway.cidrv4; #"172.31.1.1";
          GatewayOnLink = true;
        }
      ];
      matchConfig.MACAddress = icfg.mac;
      networkConfig.IPv6PrivacyExtensions = "yes";
      linkConfig.RequiredForOnline = "routable";
    };
    "50-${wgName}" = {
      # name = "${wgName}";
      matchConfig.Name = "${wgName}";
      address = [globals.net.proxy-vps.hosts."HL-4-PAZ-PROXY-01".cidrv4];
      networkConfig = {
        IPv4Forwarding = true;
        # If DNS requests should go to a specific nameserver when the tunnel is
        # established, uncomment this line and set it to the address of that
        # nameserver. But see the note at the bottom of this page.
        # DNS = "1.1.1.1";
      };
    };
  };
  # |----------------------------------------------------------------------| #
  systemd.network = {
    netdevs = {
      "40-${wgName}" = {
        netdevConfig = {
          Kind = "wireguard";
          Name = "${wgName}";
          # MTUBytes = "1300";
        };
        wireguardConfig = {
          PrivateKeyFile = config.age.secrets.private-key.path;
          ListenPort = wireguardPort;
        };
        wireguardPeers = [
          {
            # Public key of the peer (not a file path).
            # PublicKey = builtins.readFile (peerPublicKeyPath nodeName secretsPath);
            PublicKey = "GgyruHwl/IUc31jy05eqLUMk3dmS4796zwTydbt+UiY=";
            # File pointing to preshared key as generated by wg genpsk.
            # This option adds an additional layer of symmetric-key cryptography to be mixed
            #into the already existing public-key cryptography, for post-quantum resistance.
            PresharedKeyFile = config.age.secrets.preshared-key.path;
            # List of IPs assigned to this peer within the tunnel subnet. Used to configure routing.
            AllowedIPs = ["10.46.0.1/32" "10.15.70.1/32"];
            # It represents, in seconds, between 1 and 65535 inclusive,
            # how often to send an authenticated empty packet to the peer,
            # for the purpose of keeping a stateful firewall or NAT mapping valid persistently.
            PersistentKeepalive = 25;
            # Endpoint = "92.116.142.216:51820";
          }
        ];
      };
    };
  };

  # |----------------------------------------------------------------------| #

  # port forwarding
  # PreUp = iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j DNAT --to-destination 10.10.10.2:80
  # PreUp = iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j DNAT --to-destination 10.10.10.2:80
  # PostDown = iptables -t nat -D PREROUTING -i eth0 -p tcp --dport 80 -j DNAT --to-destination 10.10.10.2:80
  networking.firewall.allowedUDPPorts = [51820];
  networking.firewall.allowedTCPPorts = [8095 8090];

  networking.nftables.chains.forward.dnat = {
    after = ["conntrack"];
    rules = ["ct status dnat accept"];
  };
  networking.nftables.firewall = {
    zones = {
      untrusted.interfaces = ["ens3"];
      lan.interfaces = ["lan-self"];
      proxy-vps.interfaces = ["${wgName}"];
    };

    rules = {
      masquerade = {
        from = ["${wgName}"];
        to = ["untrusted"];
        masquerade = true;
      };

      outbound = {
        from = ["${wgName}"];
        to = ["untrusted"];
        late = true; # Only accept after any rejects have been processed
        verdict = "accept";
      };

      lan-to-local = {
        from = ["lan"];
        to = ["local"];

        allowedUDPPorts = [wireguardPort];
      };

      #     # Forward traffic between participants
      #     forward-proxy-home-vpn-traffic = {
      #       from = ["proxy-home"];
      #       to = ["proxy-home"];
      #       verdict = "accept";
      #     };
    };
  };
}
